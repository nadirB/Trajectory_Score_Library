;inits
@macro_def @init_TSL($RT_TEMPO) {
antescofo::suivi 0
temporal $RT_TEMPO
@player(0,0,0,0)
@multiplayer(0,0)

/* ::rectilinear(src=1, a=-1, b=1, alpha=0, beta=0, speed=1/64)
::rectilinear(src=2, a=1, b=1, alpha=0, beta=0, speed=1/64)
::rectilinear(src=3, a=1, b=-1, alpha=0, beta=0, speed=1/64)
::rectilinear(src=4, a=-1, b=-1, alpha=0, beta=0, speed=1/64) */
}


@macro_def @src_clear($src) {
  $prefix := "/spat/serv"
  oscsend source "127.0.0.1" : 4072 $prefix
  source "clr" $src
}

@proc_def ::src_clearAll($sources){

  forall $src in $sources
  {

    $prefix := "/spat/serv"
    oscsend source "127.0.0.1" : 4072 $prefix
    source "clr" ($src+1)

  }
}


@macro_def @alg($src, $alg) {

  $prefix := "/spat/serv"
  oscsend engine "127.0.0.1" : 4072 $prefix
  engine "alg" $src $alg ;sets a source hybrid spatialisation mode : dome or cube in hybrid mode
}

;audio players presets

@macro_def @player($sf1=1, $loop=0, $gain1=0.7, $ch=1) {
    play $sf1
    play_loop $loop
    play_gain $gain1
    play_channel $ch
}


;@player(4, 1, 0.5, 4)

@macro_def @multiplayer($sf2, $gain2) {
    playAll $sf2
    playAll_gain $gain2
}

;random generation

@fun_def @rand_range($min, $max) {@rand($max-$min)+$min}
;print_antescofo @rand_range(-1, 1)

@fun_def @rand_range_dur($min, $max) {@rand($max-$min)+$min}
;print_antescofo @rand_range(-1, 1)


;Conversions

@global $deg, $rad, $pi
$pi := 3.141592653589793

@fun_def @rad2deg($rad) {
return $rad*(180/$pi)
}

@fun_def @deg2rad($deg) {
return $deg/180 ;Should be $deg*$pi/180 but $iniT & $targeT are already multiplied by $pi in the inserted traj process !!
}

/* print_message @deg2rad(90)
print_message @rad2deg(0.5) */


@fun_def @poltocar($r, $angle)
{
	@local $x, $y
	$x := $r * @cos(@deg2rad($angle))
	$y := $r * @sin(@deg2rad($angle))
	return [$x, $y]
}

;print_antescofo @poltocar(1, 135)


@fun_def beat2msec($X) {
	1000*$X*60.0/$RT_TEMPO
}

@fun_def msec2beat($X) {
	$X*$RT_TEMPO/(1000*60.0)
}

@fun_def beat2sec($X) {
	$X*60.0/$RT_TEMPO
}

@fun_def beat2ticks($X) {
	$X*4*480
}

@MACRO_DEF hz2ms($hz)
{
	expr{ (1/$hz)*1000.0 }
}

@MACRO_DEF hz2beat($hz)
{
	expr{ (1/$hz)*($RT_TEMPO/60.0) }
}

@fun_def hz_bms($hz)
{
	 (1/$hz)*1000.0*($RT_TEMPO/60.0)
}

;trajectory scenes & utils


@macro_def @trajTranslation($what, $dur) {
    curve offset @grain := 0.01s , @Action := {$what := $x}
     {
         $x
         {
                {0.0}
         $dur/4 {1.0}
         $dur/4 {-1}
         $dur/4 {0.0}

         }
     }
}


@macro_def @square($dur1,$dur2,$dur3,$dur4) {

::rectilinear(1, 0, 2, -1,  1,  1,  0, 	1, $dur1)
$dur1
::rectilinear(1, 0, 2,  1,  1, 	0, -1, 	1, $dur2)
$dur2
::rectilinear(1, 0, 2,  1, -1,  -1, 	0, 	1, $dur3)
$dur3
::rectilinear(1, 0, 2, -1, -1,   0, 1, 	1, $dur4)
}
